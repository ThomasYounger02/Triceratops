# Selenium

# 1. Selenium

Selenium 是一个**Web应用**的**自动化框架**。

通过它，可以写出自动化程序，像人一样在浏览器里操作web界面。 比如点击界面按钮，在文本框中输入文字等操作。

而且还能从web界面获取信息。 比如获取12306票务信息，招聘网站职位信息，财经网站股票价格信息等等，然后用程序进行分析处理。

Selenium的自动化流程：

1. 自动化程序调用Selenium **客户端**库函数（比如点击按钮元素）;
2. 客户端库会发送Selenium 命令给浏览器的**驱动程序;**
3. 浏览器驱动程序接收到命令后 ,驱动**浏览器**去执行命令;
4. 浏览器执行命令;
5. 浏览器驱动程序获取命令执行的结果，返回给我们自动化程序;
6. 自动化程序对返回结果进行处理;

图例示意整个过程

## 1.1. 安装

Selenium环境的安装主要就是安装两样东西： 客户端库和浏览器驱动。

Python语言的Selenium客户端库安装：

```bash
pip install selenium
```

**浏览器驱动是和浏览器对应的**。 不同的浏览器需要选择不同的浏览器驱动。

目前主流的浏览器中， Chrome浏览器对Selenium自动化的支持更加成熟一些。[Chrome驱动下载](https://chromedriver.storage.googleapis.com/index.html)

```python
from selenium import webdriver

# 创建 WebDriver 对象，指明使用chrome浏览器驱动
# 运行浏览器驱动，并且运行Chrome浏览器
driver = webdriver.Chrome(r'd:\webdrivers\chromedriver.exe')

# 调用WebDriver对象的get方法 可以让浏览器打开指定网址
# 使用 WebDriver 的 get 方法 打开网址 百度
driver.get('https://www.baidu.com')
```

执行上面这行代码时，自动化程序就发起了打开百度网址的 `请求消息` ，通过浏览器驱动， 给 Chrome浏览器。

Chome浏览器接收到该请求后，就会打开百度网址，通过浏览器驱动， 告诉自动化程序打开成功。

按`F12`，观察HTML的内容。

## 1.2. 环境变量

添加环境变量。

```bash

```

把浏览器驱动 所在目录 加入环境变量 Path， 再写代码时，就可以无需指定浏览器驱动路径了。

```python
driver = webdriver.Chrome()
```

# 2. 选择元素

web界面自动化，要操控元素，首先需要 选择 界面元素 ，或者说 定位 界面元素。

必须要让浏览器 **先找到元素**，然后，**才能操作元素**。

## 2.1. 根据元素的id属性选择元素

根据规范， 如果元素有id属性 ，这个id 必须是当前html中唯一的。

所以如果元素有id， 根据id选择元素是最简单高效的方式。

```python
driver.find_element_by_id('kw')
```

运行这行代码就会发起一个请求通过 浏览器驱动 转发给浏览器，告诉它，需要选择一个id为 kw 的元素。浏览器，找到id为kw的元素后，将结果通过浏览器驱动返回给自动化程序， 所以 `find_element_by_id`方法会返回一个`WebElement 类型的对象`。

## 2.2. 根据 class属性选择元素

class 属性用来标志元素类型。

```python
driver.find_elements_by_class_name('animal')
```

find_elements_by_class_name 方法返回的是找到的符合条件的所有元素， 放在一个列表中返回。

```html
<span class="chinese student">张三</span>
```

这里 span元素有两个class属性，分别 是 chinese 和 student， 而不是一个 名为 chinese student 的属性。

```python
driver.find_elements_by_class_name('chinese')         # 正确
driver.find_elements_by_class_name('student')         # 正确
driver.find_elements_by_class_name('chinese student')         # 错误
```

## 2.3. 根据 tag 名 选择元素

可以通过方法 find_elements_by_tag_name ，选择所有的tag名为 div的元素。

```python
elements = driver.find_elements_by_tag_name('div')

# text属性就是该 WebElement对象对应的元素在网页中的文本内容
for element in elements:
    print(element.text)
```

**find_element 和 find_elements 的区别:**

- 使用 `find_elements` 选择的是符合条件的 `所有` 元素， 如果没有符合条件的元素， `返回空列表`
- 使用 `find_element` 选择的是符合条件的 `第一个` 元素， 如果没有符合条件的元素， `抛出 NoSuchElementException 异常`

## 2.4. 通过WebElement对象选择元素

不仅WebDriver对象有选择元素的方法， WebElement对象也有选择元素的方法。WebElement对象 也可以调用 `find_elements_by_xxx`， `find_element_by_xxx` 之类的方法。WebDriver对象选择元素的范围是整个web页面， 而WebElement对象选择元素的范围是 该元素的内部。

```python
element = driver.find_element_by_id('container')

# 限制 选择元素的范围是 id 为 container 元素的内部。
spans = element.find_elements_by_tag_name('span')
```

## 2.5. 等待界面元素出现

在进行网页操作的时候， 有的元素内容不是可以立即出现的， 可能会等待一段时间。

当发现元素没有找到的时候， 并不立即返回找不到元素的错误。而是周期性（每隔半秒钟）重新寻找该元素，直到该元素找到，或者超出指定最大等待时长，这时才 抛出异常（如果是 `find_elements` 之类的方法， 则是返回空列表）。

```python
# 每隔 半秒钟 再去界面上查看一次， 直到找到该元素， 或者 过了10秒 最大时长
driver.implicitly_wait(10)
```

<aside>
💡 implicitly_wait在元素没有找到的时候才会生效。

</aside>

有的情况下，仍然需要sleep。比如，前后两个选择框，有关联。对第一个选择框进行自动操作后，第二个选择框很可能没有来得及变动，这个时候需要使用sleep。

# 3. 操控元素

操控元素通常包括：

- 点击元素；
- 在元素中输入字符串，通常是对输入框这样的元素；
- 获取元素包含的信息，比如文本内容，元素的属性；

## 3.1. 点击元素

调用元素WebElement对象的`click`方法。

调用 WebElement 对象的click方法去点击元素的时候， 浏览器接收到自动化命令，点击的是该元素的中心点位置 。

```python
driver.find_element_by_id('su').click()
```

## 3.2. 输入框

用元素WebElement对象的`send_keys`方法。

如果要把输入框中已经有的内容清除掉，可以使用WebElement对象的`clear`方法

```python
element = driver.find_element_by_id("input1")

element.clear()    # 清除输入框已有的字符串
element.send_keys('白月黑羽')     # 输入新字符串
```

## 3.3. 获取元素信息

### 3.3.1 获取元素的文本内容

通过WebElement对象的`text`属性，可以获取元素展示在界面上的文本内容。

```python
element = driver.find_element_by_id('animal')
print(element.text)
```

但是，有时候，元素的文本内容没有展示在界面上，或者没有完全完全展示在界面上。 这时，用WebElement对象的text属性，获取文本内容，就会有问题。

```python
element.get_attribute('innerText')
element.get_attribute('textContent')
```

### 3.3.2 获取元素的属性

通过WebElement对象的`get_attribute`方法来获取元素的属性值。

```python
element = driver.find_element_by_id('input_name')
print(element.get_attribute('class'))
```

## 3.4. 获取整个元素对应的HTML

要获取整个元素对应的HTML文本内容，可以使用 `element.get_attribute('outerHTML')`。

获取某个元素内部的HTML文本内容，可以使用 `element.get_attribute('innerHTML')`。

```python
# 整个HTML, 用于静态分析
element.get_attribute('outerHTML')

# 内部的HTML
element.get_attribute('innerHTML')
```

## 3.5. 获取输入框里面的文字

对于input输入框的元素，要获取里面的输入文本，用text属性是不行的。可以使用`element.get_attribute('value')`。

```python
element = driver.find_element_by_id("input1")
print(element.get_attribute('value'))     # 获取输入框中的文本
```

# 4. CSS表达式

如果我们要选择的元素没有id、class 属性，或者有些我们不想选择的元素也有相同的id、class属性值。

这时候我们通常可以通过 CSS selector 语法选择元素。

## 4.1. CSS Selector 语法选择元素原理

HTML中经常要为某些元素 指定 显示效果，比如前景文字颜色是红色， 背景颜色是黑色， 字体是微软雅黑等。

那么CSS必须告诉浏览器：要选择哪些元素 ， 来使用这样的显示风格。

```css
/* CSS选择器 {展示样式} */
.animal {color: red}
```

指定了class 值为animal的元素，要显示为红色。`.animal` 就是 CSS Selector ，或者说 CSS 选择器。

```python
# .后面不能有空格
driver.find_element_by_css_selector('.animal')
driver.find_elements_by_css_selector('.plant')
```

## 4.2. 根据 tag名、id、class 选择元素

CSS Selector 同样可以根据tag名、id 属性和 class属性来选择元素。

```python
# 两者等价
driver.find_elements_by_css_selector('div')
driver.find_elements_by_tag_name('div')
```

根据id属性 选择元素的语法是在id号前面加上一个井号： `#id值`

```html
<input  type="text" id='searchtext' />
```

```python
# #后面不能有空格
driver.find_element_by_css_selector('#searchtext')
```

根据class属性 选择元素的语法是在 class 值 前面加上一个点： `.class值`

```python
driver.find_elements_by_css_selector('.animal')
driver.find_elements_by_class_name('animal')
```

## 4.3. 选择 子元素 和 后代元素

HTML中，元素内部可以包含其他元素。

```html
<div id='container'>
    
    <div id='layer1'>
        <div id='inner11'>
            <span>内层11</span>
        </div>
        <div id='inner12'>
            <span>内层12</span>
        </div>
    </div>

    <div id='layer2'>
        <div id='inner21'>
            <span>内层21</span>
        </div>
    </div>
    
</div>
```

id 为 `container` 的div元素 包含了 id 为 `layer1` 和 `layer2` 的两个div元素。

这种包含是直接包含， 中间没有其他的层次的元素了。 所以 id 为 `layer1` 和 `layer2` 的两个div元素是id为 `container` 的div元素 的 **直接子元素。**

而 id 为 `layer1` 的div元素 又包含了 id 为 `inner11` 和 `inner12` 的两个div元素。 中间没有其他层次的元素，所以这种包含关系也是 **直接子元素** 关系。

id 为 `layer2` 的div元素 又包含了 id 为 `inner21` 这个div元素。 这种包含关系也是 **直接子元素** 关系

而对于 id 为 `container` 的div元素来说， id 为 `inner11` 、`inner12` 、`inner22` 的元素 和 两个 `span类型的元素` 都不是 它的直接子元素， 因为中间隔了 几层。

虽然不是直接子元素， 但是 它们还是在 `container` 的内部， 可以称之为它 的 **后代元素。**

后代元素也包括了直接子元素， 比如 id 为 `layer1` 和 `layer2` 的两个div元素 也可以说 是 id 为 `container` 的div元素 的 **直接子元素，同时也是后代子元素**

如果 元素2 是 元素1 的 直接子元素， CSS Selector 选择子元素的语法是这样的:

```css
/* 元素1 > 元素2 */
```

中间用一个大于号 （我们可以理解为箭头号）。注意，最终选择的元素是 **元素2**， 并且要求这个 **元素2** 是 **元素1** 的直接子元素

也支持更多层级的选择：

```css
/* 元素1 > 元素2 > 元素3 > 元素4 */
#Plant > .plant
#container > div
```

```css
driver.find_element_by_css_selector('#container > div')
driver.find_element_by_css_selector('#layer1 > div')
driver.find_element_by_css_selector('#layer1 span')   
```

就是选择 元素1 里面的子元素 元素2 里面的子元素 元素3 里面的子元素 元素4 ， 最终选择的元素是 元素4。

如果 元素2 是 元素1 的 后代元素， CSS Selector 选择后代元素的语法是这样的：

```css
/* 元素1   元素2*/
```

中间是**一个或者多个空格**隔开。最终选择的元素是 **元素2** ， 并且要求这个 **元素2** 是 **元素1** 的后代元素。

也支持更多层级的选择， 比如：

```css
/* 元素1   元素2   元素3  元素4 */
```

最终选择的元素是 元素4。

两者可以混用。

```css
/*元素1 元素2 > 元素3 元素4*/
```

## 4.4. 根据属性选择

id、class 都是web元素的 ```属性``` ，因为它们是很常用的属性，所以css选择器专门提供了根据 id、class 选择的语法。

其他的属性，如： `<a href="http://www.miitbeian.gov.cn">苏ICP备88885574号</a>` 里面根据 href选择，可以用css 选择器。

css 选择器支持通过任何属性来选择元素，语法是用一个方括号 `[]` 。

比如要选择上面的a元素，就可以使用 `[href="http://www.miitbeian.gov.cn"]` 。这个表达式的意思是，选择属性href值为 `http://www.miitbeian.gov.cn` 的元素。

```python
# 根据属性选择元素
element = driver.find_element_by_css_selector('[href="http://www.miitbeian.gov.cn"]')

# 打印出元素对应的html
print(element.get_attribute('outerHTML'))
```

前面可以加上标签名的限制，比如 `div[class='SKnet']` 表示选择所有标签名为div，且class属性值为SKnet的元素。

```css
div[class='SKnet']
.plant[name='Sknet']
```

属性值用单引号，双引号都可以。

根据属性选择，还可以不指定属性值，比如 `[href]` ， 表示选择所有具有属性名为href 的元素，不管它们的值是什么。

CSS 还可以选择属性值`包含`某个字符串的元素。

```python
# 比如， 要选择a节点，里面的href属性包含了 miitbeian 字符串，就可以这样写。
a[href*="miitbeian"]
```

选择属性值以某个字符串`开头`的元素。

```python
# 要选择a节点，里面的href属性以 http 开头。
a[href^="http"]
```

选择 属性值 以某个字符串 `结尾` 的元素。

```python
# 要选择a节点，里面的href属性以 gov.cn 结尾
a[href$="gov.cn"]
```

如果一个元素具有多个属性。

```html
<div class="misc" ctype="gun">沙漠之鹰</div>
```

CSS 选择器 可以指定选择的元素要同时具有多个属性的限制。

```css
div[class="misc"][ctype="gun"]
#ok .plant > div[href="http://www.miitbeian.gov.cn"]
```

## 4.5. 验证 CSS Selector

怎么验证 CSS Selector 的语法是否正确选择了我们要选择的元素呢？

写出Python代码，运行看看，能否操作成功。

```python
element = wd.find_element_by_css_selector('#searchtext')
element.input('输入的文本')
```

验证 下面的表达式：

```css
#bottom > .footer2  a

```

能否选中 这个元素：

```html
<a href="http://www.miitbeian.gov.cn">苏ICP备88885574号</a>
```

在Chrome中，通过检查Elements，`Ctrl+F`搜索表达式`#bottom > .footer2  a`

`1 of 1`， 表示选择的目标唯一。

## 4.6. 选择语法联合使用

比如， 我们要选择 网页 html 中的元素 `<span class='copyright'>版权</span>`。

```html
<div id='bottom'>
    <div class='footer1'>
        <span class='copyright'>版权</span>
        <span class='date'>发布日期：2018-03-03</span>
    </div>
    <div class='footer2'>
        <span>备案号
            <a href="http://www.miitbeian.gov.cn">苏ICP备88885574号</a>
        </span>
    </div>        
</div>
```

CSS selector 表达式

```css
div.footer1 > span.copyright
```

选择 一个class 属性值为 copyright 的 span 节点， 并且要求其 必须是 class 属性值为 footer1 的 div节点 的子节点。

```css
.footer1 > .copyright
```

选择 一个class 属性值为copyright 的节点（不限类型）， 并且要求其 必须是 class 属性值为 footer1 的节点的 子节点。

也可以：

```css
.footer1  .copyright
```

因为子元素同时也是后代元素。

## 4.7. 组选择

如果我们要 同时选择所有class 为 plant `和` class 为 animal 的元素。怎么办？

这种情况，css选择器可以 使用 `逗号` ，称之为 组选择 ，像这样：

```css
.plant , .animal      /* 可以在chrome中验证 */
```

```python
# 同时选择所有tag名为div的元素 和 id为BYHY的元素
elements = wd.find_elements_by_css_selector('div, #BYHY')
for element in elements:
    print(element.text)
```

```css
/* # 选择所有 id 为 t1 里面的 span 和 所有的 p 元素 */
#t1 > span,p

/* 选择所有 id 为 t1 里面的 span 和 p 元素 */
#t1 > span , #t1 > p
```

## 4.8. 按次序选择子节点

```html
<body>  
       <div id='t1'>
           <h3> 唐诗 </h3>
           <span>李白</span>
           <p>静夜思</p>
           <span>杜甫</span>
           <p>春夜喜雨</p>              
       </div>      
        
       <div id='t2'>
           <h3> 宋词 </h3>
           <span>苏轼</span>
           <p>赤壁怀古</p>
           <p>明月几时有</p>
           <p>江城子·乙卯正月二十日夜记梦</p>
           <p>蝶恋花·春景</p>
           <span>辛弃疾</span>
           <p>京口北固亭怀古</p>
           <p>青玉案·元夕</p>
           <p>西江月·夜行黄沙道中</p>
       </div>             

    </body>
```

### 4.8.1 **父元素的第n个子节点**

指定选择的元素 `是父元素的第几个子节点`使用 `nth-child`。

```css
span:nth-child(2)
:nth-child(2)
```

我们要选择唐诗和宋词的第一个作者，

也就是说 选择的是 第2个子元素，并且是span类型。

所以这样可以这样写 `span:nth-child(2)` ，

如果你不加节点类型限制，直接这样写 `:nth-child(2)`

就是选择所有位置为第2个的所有元素，不管是什么类型。

### 4.8.2. 父元素的倒数第n个子节点

也可以反过来， 选择的是父元素的倒数第几个子节点 ，使用 nth-last-child

```css
p:nth-last-child(1)
```

就是选择第倒数第1个子元素，并且是p元素。

### 4.8.3. 父元素的第几个某类型的子节点

我们可以指定选择的元素 是父元素的第几个 `某类型的` 子节点

使用 `nth-of-type`

```css
span:nth-of-type(1)
```

我们要选择 唐诗 和宋词 的第一个 作者，

可以像上面那样思考：选择的是 第2个子元素，并且是span类型

所以这样可以这样写 `span:nth-child(2)` ，

还可以这样思考，选择的是 `第1个span类型` 的子元素

所以也可以这样写 `span:nth-of-type(1)`

### 4.8.4. 父元素的倒数第几个某类型的子节点

当然也可以反过来， 选择父元素的 `倒数第几个某类型` 的子节点。

使用 `nth-last-of-type`

```css
p:nth-last-of-type(2)
```

### 4.8.5. 奇数节点和偶数节点

如果要选择的是父元素的 `偶数节点`，使用 `nth-child(even)`

```css
p:nth-child(even)
```

如果要选择的是父元素的 奇数节点，使用 `nth-child(odd)`

```css
p:nth-child(odd)
```

如果要选择的是父元素的 `某类型偶数节点`，使用 `nth-of-type(even)`

如果要选择的是父元素的 `某类型奇数节点`，使用 `nth-of-type(odd)`

```css
#t1:nth-child(even)
#t2 p:nth-of-type(odd)
```

## 4.9. 兄弟节点选择

### 4.9.1. 相邻兄弟节点选择

上面的例子里面，我们要选择 唐诗 和宋词 的第一个 作者

还有一种思考方法，就是选择 h3 `后面紧跟着的兄弟节点` span。

这就是一种 相邻兄弟 关系，可以这样写 `h3 + span`

表示元素 紧跟关系的 是 `加号`

```css
h3 + span
```

### 4.9.2. 后续所有兄弟节点选择

如果要选择是 选择 h3 后面所有的兄弟节点 span，可以这样写 h3 ~ span

```css
#t1:h3 ~ span
```

# 5. Frame切换/窗口切换

iframe 元素非常的特殊， 在html语法中，`frame元素` 或者`iframe元素`的内部会包含一个**被嵌入的**另一份html文档。

在我们使用selenium打开一个网页是， 我们的操作范围缺省是当前的html ， 并不包含被嵌入的html文档里面的内容。

如果我们要 操作 被嵌入的 html 文档 中的元素， 就必须 `切换操作范围` 到 被嵌入的文档中。

使用 WebDriver 对象的 `switch_to` 属性，像这样

```python
driver.switch_to.frame('frame_reference')
```

其中， frame_reference 可以是 frame 元素的属性 **name 或者 ID** 。

比如这里，就可以填写 iframe元素的id ‘frame1’ 或者 name属性值 ‘innerFrame’。

```python
driver.switch_to.frame('frame1')
driver.switch_to.frame('innerFrame')
```

也可以填写frame 所对应的 WebElement 对象。

我们可以根据frame的元素位置或者属性特性，使用find系列的方法，选择到该元素，得到对应的WebElement对象。

```python
driver.switch_to.frame(driver.find_element_by_tag_name("iframe"))
driver.switch_to.frame(driver.find_element_by_css_selector("[src='sample.html']"))
```

就可以进行后续操作frame里面的元素了。

```python
# 先根据name属性值 'innerFrame'，切换到iframe中
driver.switch_to.frame('innerFrame')

# 根据class name选择元素，返回的是 一个列表
elements = driver.find_elements_by_class_name('plant')

for element in elements:
    print(element.text)
```

如果我们已经切换到某个iframe里面进行操作了，那么后续选择和操作界面元素 就都是在这个frame里面进行的。

这时候，如果我们又需要操作 主html（我们把最外部的html称之为主html） 里面的元素了呢？

怎么切换回原来的主html呢？

```python
driver.switch_to.default_content()
```

在上面 代码 操作完 frame里面的元素后， 需要 点击 主html 里面的按钮，就可以这样写

```python
# 先根据name属性值 'innerFrame'，切换到iframe中
driver.switch_to.frame('innerFrame')

# 根据 class name 选择元素，返回的是 一个列表
elements = driver.find_elements_by_class_name('plant')

for element in elements:
    print(element.text)

# 切换回 最外部的 HTML 中
driver.switch_to.default_content()

# 然后再 选择操作 外部的 HTML 中 的元素
driver.find_element_by_id('outerbutton').click()

driver.quit()
```

## 5.1. 切换到新的窗口

在网页上操作的时候，我们经常遇到，点击一个链接 或者 按钮，就会打开一个 新窗口 。

在打开的网页中，点击 链接 “访问bing网站” ， 就会弹出一个新窗口，访问bing网址。

如果我们用Selenium写自动化程序 **在新窗口里面 打开一个新网址**， 并且去自动化操作新窗口里面的元素，会有什么问题呢？

问题就在于，即使新窗口打开了， 这时候，我们的 WebDriver对象对应的 还是老窗口，自动化操作也还是在老窗口进行。

可以使用Webdriver对象的`switch_to`属性的 `window`方法，如下所示：

```css
driver.switch_to.window(handle)
```

其中，参数handle需要传入什么呢？

WebDriver对象有window_handles 属性，这是一个列表对象， 里面包括了当前浏览器里面**所有的窗口句柄**。

所谓句柄，大家可以想象成对应网页窗口的一个ID，

那么我们就可以通过 类似下面的代码，

```python
for handle in driver.window_handles:
    # 先切换到该窗口
    driver.switch_to.window(handle)
    # 得到该窗口的标题栏字符串，判断是不是我们要操作的那个窗口
    if 'Bing' in driver.title:
        # title为当前窗口的标题栏
        # 如果是，那么这时候WebDriver对象就是对应的该该窗口，正好，跳出循环，
        break
```

我们依次获取 driver.window_handles 里面的所有句柄对象， 并且调用 driver.switch_to.window(handle) 方法，切入到每个窗口，

然后检查里面该窗口对象的属性（可以是标题栏，地址栏），判断是不是我们要操作的那个窗口，如果是，就跳出循环。

同样的，如果我们在新窗口 操作结束后， 还要回到原来的窗口，该怎么办？

我们可以仍然使用上面的方法，依次切入窗口，然后根据 标题栏 之类的属性值判断。

因为我们一开始就在 原来的窗口里面，我们知道 进入新窗口操作完后，还要回来，可以事先 保存该老窗口的 句柄，使用如下方法

```python
# mainWindow变量保存当前窗口的句柄
mainWindow = driver.current_window_handle
```

切换到新窗口操作完后，就可以直接像下面这样，将driver对应的对象返回到原来的窗口

```python
# 通过前面保存的老窗口的句柄，自己切换到老窗口
driver.switch_to.window(mainWindow)
```

# 6. 选择框

常见的选择框包括： radio框、checkbox框、select框。

对应的样子，示例

## 6.1. radio框

radio框选择选项，直接用WebElement的click方法，模拟用户点击就可以了。

比如, 我们要在下面的html中：

```html
<div id="s_radio">
  <input type="radio" name="teacher" value="小江老师">小江老师<br>
  <input type="radio" name="teacher" value="小雷老师">小雷老师<br>
  <input type="radio" name="teacher" value="小凯老师" checked="checked">小凯老师
</div>
```

- 先打印当前选中的老师名字
- 再选择 小雷老师

对应的代码如下

```python
# 获取当前选中的元素
element = driver.find_element_by_css_selector(
  '#s_radio input[checked=checked]')
print('当前选中的是: ' + element.get_attribute('value'))

# 点选 小雷老师
driver.find_element_by_css_selector(
  '#s_radio input[value="小雷老师"]').click()
```

## 6.2. checkbox框

对checkbox进行选择，也是直接用 WebElement 的 click 方法，模拟用户点击选择。

需要注意的是，要选中checkbox的一个选项，必须 `先获取当前该复选框的状态` ，如果该选项已经勾选了，就不能再点击。否则反而会取消选择。

比如, 我们要在下面的html中：选中 小雷老师

```html
<div id="s_checkbox">
  <input type="checkbox" name="teacher" value="小江老师">小江老师<br>
  <input type="checkbox" name="teacher" value="小雷老师">小雷老师<br>
  <input type="checkbox" name="teacher" value="小凯老师" checked="checked">小凯老师
</div>
```

我们的思路可以是这样：

- 先把 已经选中的选项全部点击一下，确保都是未选状态
- 再点击 小雷老师

```python
# 先把 已经选中的选项全部点击一下
elements = driver.find_elements_by_css_selector(
  '#s_checkbox input[checked="checked"]')

for element in elements:
    element.click()

# 再点击 小雷老师
driver.find_element_by_css_selector(
  "#s_checkbox input[value='小雷老师']").click()
```

## 6.3. select框

radio框及checkbox框都是input元素，只是里面的type不同而已。

select框 则是一个新的select标签。

对于Select 选择框， Selenium 专门提供了一个 `Select类` 进行操作。

Select类 提供了如下的方法

`select_by_value`根据选项的 value属性值 ，选择元素。

```html
<option value="foo">Bar</option>
```

就可以根据 foo 这个值选择该选项，

```python
s.select_by_value('foo')
```

`select_by_index`根据选项的 次序 （从0开始），选择元素？？？？？

`select_by_visible_text`根据选项的 可见文本 ，选择元素。

```python
<option value="foo">Bar</option>
```

就可以根据 Bar 这个内容，选择该选项

```python
s.select_by_visible_text('Bar')
```

`deselect_by_value`根据选项的value属性值， 去除 选中元素

`deselect_by_index`根据选项的次序，去除 选中元素

`deselect_by_visible_text`根据选项的可见文本，去除 选中元素

`deselect_all`去除 选中所有元素

### Select单选框

对于 select单选框，操作比较简单：

不管原来选的是什么，直接用Select方法选择即可。

例如，选择示例里面的小雷老师，示例代码如下

```python
# 导入Select类
from selenium.webdriver.support.ui import Select

# 创建Select对象
select = Select(driver.find_element_by_id("ss_single"))    # select标签的id

# 通过 Select 对象选中小雷老师
select.select_by_visible_text("小雷老师")
```

### Select多选框

对于select多选框，要选中某几个选项，要注意去掉原来已经选中的选项。

例如，我们选择示例多选框中的 小雷老师 和 小凯老师

可以用select类 的deselect_all方法，清除所有 已经选中 的选项。

然后再通过 select_by_visible_text方法 选择 小雷老师 和 小凯老师。

示例代码如下：

```python
# 导入Select类
from selenium.webdriver.support.ui import Select

# 创建Select对象
select = Select(driver.find_element_by_id("ss_multi"))

# 清除所有 已经选中 的选项
select.deselect_all()

# 选择小雷老师 和 小凯老师
select.select_by_visible_text("小雷老师")
select.select_by_visible_text("小凯老师")
```

# Xpath选择器

## Xpath语法

还有一种 灵活、强大 的选择元素的方式，就是使用 `Xpath` 表达式。

XPath (XML Path Language) 是由国际标准化组织W3C指定的，用来在 XML 和 HTML 文档中选择节点的语言。

目前主流浏览器 (chrome、firefox，edge，safari) 都支持XPath语法，xpath有 1 和 2 两个版本，目前浏览器支持的是 xpath 1的语法。

既然已经有了CSS，为什么还要学习 Xpath呢？ 因为

- 有些场景 用 css 选择web 元素 很麻烦，而xpath 却比较方便。
- 另外 Xpath 还有其他领域会使用到，比如 爬虫框架 Scrapy， 手机App框架 Appium。

按F12打开调试窗口，点击 Elements标签。

要验证 Xpath 语法是否能成功选择元素，也可以像 验证 CSS 语法那样，按组合键 Ctrl + F ，就会出现 搜索框

xpath 语法中，整个HTML文档根节点用’/‘表示，如果我们想选择的是根节点下面的html节点，则可以在搜索框输入

```
/html
```

如果输入下面的表达式

```
/html/body/div
```

这个表达式表示选择html下面的body下面的div元素。

注意 `/` 有点像 CSS中的 `>` , 表示直接子节点关系。

### 绝对路径选择

从根节点开始的，到某个节点，每层都依次写下来，每层之间用 `/` 分隔的表达式，就是某元素的 `绝对路径`

上面的xpath表达式 `/html/body/div` ，就是一个绝对路径的xpath表达式， 等价于 css表达式 `html>body>div`

自动化程序要使用Xpath来选择web元素，应该调用 WebDriver对象的方法 `find_element_by_xpath` 或者 `find_elements_by_xpath`，像这样：

```python
elements = driver.find_elements_by_xpath("/html/body/div")
```

### 相对路径选择

有的时候，我们需要选择网页中某个元素， `不管它在什么位置` 。

比如，选择示例页面的所有标签名为 `div` 的元素，如果使用css表达式，直接写一个 `div` 就行了。

那xpath怎么实现同样的功能呢？ xpath需要前面加 `//` , 表示从当前节点往下寻找所有的后代元素,不管它在什么位置。

所以xpath表达式，应该这样写： `//div`

‘//’ 符号也可以继续加在后面,比如，要选择 所有的 div 元素里面的 所有的 p 元素 ，不管div 在什么位置，也不管p元素在div下面的什么位置，则可以这样写 `//div//p`

对应的自动化程序如下

```python
elements = driver.find_elements_by_xpath("//div//p")
```

如果使用CSS选择器，对应代码如下

```python
elements = driver.find_elements_by_css_selector("div p")
```

如果，要选择 所有的 div 元素里面的 直接子节点 p ， xpath，就应该这样写了 `//div/p`

如果使用CSS选择器，则为 `div > p`

### 通配符

如果要选择所有div节点的所有直接子节点，可以使用表达式 `//div/*`

`*` 是一个通配符，对应任意节点名的元素，等价于CSS选择器 `div > *`

代码如下：

```python
elements = driver.find_elements_by_xpath("//div/*")
for element in elements:
    print(element.get_attribute('outerHTML'))
```

## 根据属性选择

Xpath 可以根据属性来选择元素。

根据属性来选择元素 是通过 这种格式来的 `[@属性名='属性值']`

注意：

- 属性名注意前面有个@；
- 属性值一定要用引号， 可以是单引号，也可以是双引号；

### 根据id属性选择

选择 id 为 west 的元素，可以这样 `//*[@id='west']`

`//*[@id]`表示所有有id属性的元素。

`//p[@id]`

### 根据class属性选择

选择所有 select 元素中 class为 single_choice 的元素，可以这样 `//select[@class='single_choice']`

如果一个元素class 有多个，比如

```html
<p id="beijing" class='capital huge-city'>
    北京    
</p>
```

如果要选 它， 对应的 xpath 就应该是 `//p[@class="capital huge-city"]`

不能只写一个属性，像这样 `//p[@class="capital"]` 则不行

### 根据其他属性

同样的道理，我们也可以利用其它的属性选择

比如选择 具有multiple属性的所有页面元素 ，可以这样 `//*[@multiple]`

multiple可以没有值。

### 属性值包含字符串

要选择 style属性值 包含 color 字符串的 页面元素 ，可以这样 `//*[contains(@style,'color')]`

要选择 style属性值 以 color 字符串 `开头` 的 页面元素 ，可以这样 `//*[starts-with(@style,'color')]`

要选择 style属性值 以 某个 字符串 结尾 的 页面元素 ，大家可以推测是 `//*[ends-with(@style,'color')]`， 但是，很遗憾，这是xpath 2.0 的语法 ，目前浏览器都不支持

## 按次序选择

前面学过css表达式可以根据元素在父节点中的次序选择， 非常实用。

xpath也可以根据次序选择元素。 语法比css更简洁，直接在方括号中使用数字表示次序。

### 某类型 第几个 子元素

要选择 p类型第2个的子元素，就是

```css
//p[2]       /* p类型的第二个*/
```

注意，选择的是 `p类型第2个的子元素` ， 不是 `第2个子元素，并且是p类型` 。

注意体会区别

再比如，要选取父元素为div 中的 p类型 第2个 子元素

```css
//div/p[2]
```

### 第几个子元素

也可以选择第2个子元素，不管是什么类型，采用通配符

比如 选择父元素为div的第2个子元素，不管是什么类型

```css
//div/*[2]
```

### 某类型 倒数第几个 子元素

当然也可以选取倒数第几个子元素

比如：

- 选取p类型倒数第1个子元素

```css
//p[last()]
```

- 选取p类型倒数第2个子元素

```css
//p[last()-1]
```

- 选择父元素为div中p类型倒数第3个子元素

```css
//div/p[last()-2]
```

### 范围选择

xpath还可以选择子元素的次序范围。

比如，

- 选取option类型第1到2个子元素

```css
//option[position()<=2]

/* 或者*/
//option[position()<3]
```

- 选择class属性为multi_choice的前3个子元素

```css
//*[@class='multi_choice']/*[position()<=3]
```

- 选择class属性为multi_choice的后3个子元素

```css
//*[@class='multi_choice']/*[position()>=last()-2]
```

为什么不是 `last()-3` 呢？ 因为

`last()` 本身代表最后一个元素

`last()-1` 本身代表倒数第2个元素

`last()-2` 本身代表倒数第3个元素

## 组选择、父节点、兄弟节点

### 组选择

css有组选择，可以同时使用多个表达式，多个表达式选择的结果都是要选择的元素

css 组选择，表达式之间用 **逗号** 隔开

xpath也有组选择， 是用 **竖线** 隔开多个表达式

比如，要选所有的option元素 和所有的 h4 元素，可以使用

```
//option | //h4
```

等同于CSS选择器

```css
option , h4
```

再比如，要选所有的 class 为 single_choice 和 class 为 multi_choice 的元素，可以使用

```css
//*[@class='single_choice'] | //*[@class='multi_choice']
```

等同于CSS选择器

```css
.single_choice , .multi_choice
```

### 选择父节点

xpath可以选择父节点， 这是css做不到的。

某个元素的父节点用 `/..` 表示

比如，要选择 id 为 china 的节点的父节点，可以这样写 `//*[@id='china']/..` 。

当某个元素没有特征可以直接选择，但是它有子节点有特征， 就可以采用这种方法，先选择子节点，再指定父节点。

还可以继续找上层父节点，比如 `//*[@id='china']/../../..`

### 兄弟节点选择

前面学过 css选择器，要选择某个节点的后续兄弟节点，用 **波浪线**

xpath也可以选择 后续 兄弟节点，用这样的语法 `following-sibling::`

比如，要选择 class 为 single_choice 的元素的所有后续兄弟节点 `//*[@class='single_choice']/following-sibling::*`

等同于CSS选择器 `.single_choice ~ *`

如果，要选择后续节点中的div节点， 就应该这样写 `//*[@class='single_choice']/following-sibling::div`

xpath还可以选择 `前面的` 兄弟节点，用这样的语法 `preceding-sibling::`

比如，要选择 class 为 single_choice 的元素的所有前面的兄弟节点 `//*[@class='single_choice']/preceding-sibling::*`

而CSS选择器目前还没有方法选择前面的 兄弟节点。

## selenium 注意点

我们的代码：

- 先选择示例网页中，id是china的元素
- 然后通过这个元素的WebElement对象，使用find_elements_by_xpath，选择里面的p元素，

```python
# 先寻找id是china的元素
china = wd.find_element_by_id('china')

# 再选择该元素内部的p元素
elements = china.find_elements_by_xpath('//p')

# 打印结果
for element in elements:
    print('----------------')
    print(element.get_attribute('outerHTML'))
```

运行发现，打印的 不仅仅是 china内部的p元素， 而是所有的p元素。

要在某个元素内部使用xpath选择元素， 需要 `在xpath表达式最前面加个点 .`

像这样

```python
elements = china.find_elements_by_xpath('.//p')
```

# 关闭浏览器

浏览器窗口可以调用WebDriver对象的 quit 方法。

```python
# 关闭窗口以及驱动器
driver.quit()
```

附录

教程地址：

# 实战技巧

## 更多动作

之前我们对web元素做的操作主要是：**`选择元素`**，然后 **`点击元素`** 或者**`输入`** 字符串。

还有没有其他的操作了呢？

有。

比如：比如 `鼠标右键点击、双击、移动鼠标到某个元素、鼠标拖拽`等。

这些操作，可以通过 Selenium 提供的 `ActionChains` 类来实现。

ActionChains 类 里面提供了 一些特殊的动作的模拟，我们可以通过 ActionChains 类的代码查看到，如下所示

如果我们把鼠标放在上边，就会弹出 下面的 糯米、音乐、图片 等图标。

使用 ActionChains 来 模拟鼠标移动 操作的代码如下：

```python
from selenium import webdriver

driver = webdriver.Chrome(r'f:\chromedriver.exe')
driver.implicitly_wait(5)

driver.get('https://www.baidu.com/')

from selenium.webdriver.common.action_chains import ActionChains

ac = ActionChains(driver)

# 鼠标移动到 元素上
ac.move_to_element(
    driver.find_element_by_css_selector('[name="tj_briicon"]')
).perform()
```

## 直接执行javascript

我们可以直接让浏览器运行一段javascript代码，并且得到返回值，如下

```python
# 直接执行 javascript，里面可以直接用return返回我们需要的数据
nextPageButtonDisabled = driver.execute_script(
    '''
    ele = document.querySelector('.soupager > button:last-of-type');
    return ele.getAttribute('disabled')
    ''')

# 返回的数据转化为Python中的数据对象进行后续处理
if nextPageButtonDisabled == 'disabled': # 是最后一页
    return True
else: # 不是最后一页
    return False
```

## 冻结界面

有些网站上面的元素， 我们鼠标放在上面，会动态弹出一些内容。

比如，百度首页的右上角，有个 **更多产品** 选项，如下图所示

如果我们把鼠标放在上边，就会弹出 下面的 糯米、音乐、图片 等图标。

如果我们要用 selenium 自动化 点击 糯米图标，就需要 F12 查看这个元素的特征。

但是 当我们的鼠标 从 糯米图标 移开， 这个 栏目就整个消失了， 就没法 查看 其对应的 HTML。

怎么办？

可以如下图所示：

在 开发者工具栏 console 里面执行如下js代码

```jsx
setTimeout(function(){debugger}, 5000)
```

表示在 5000毫秒后，执行 debugger 命令

执行该命令会 浏览器会进入debug状态。 debug状态有个特性， 界面被冻住， 不管我们怎么点击界面都不会触发事件。

所以，我们可以在输入上面代码并回车 执行后， 立即 鼠标放在界面 右上角 更多产品处。

这时候，就会弹出 下面的 糯米、音乐、图片 等图标。

然后，我们仔细等待 5秒 到了以后， 界面就会因为执行了 debugger 命令而被冻住。

然后，我们就可以点击 开发者工具栏的 查看箭头， 再去 点击 糯米图标 ，查看其属性了。

## 弹出对话框

有的时候，我们经常会在操作界面的时候，出现一些弹出的对话框。

分别点击界面的3个按钮，你可以发现：

弹出的对话框有三种类型，分别是 Alert（警告信息）、confirm（确认信息）和prompt（提示输入）

### Alert

Alert 弹出框，目的就是显示通知信息，只需用户看完信息后，`点击 OK（确定）` 就可以了。

那么，自动化的时候，代码怎么模拟用户点击 OK 按钮呢？

selenium提供如下方法进行操作

```python
driver.switch_to.alert.accept()
```

注意：如果我们不去点击它，页面的其它元素是不能操作的。 {: .notice–info}

如果程序要获取弹出对话框中的信息内容， 可以通过 如下代码

```python
driver.switch_to.alert.text
```

```python
from selenium import webdriver
driver = webdriver.Chrome()
driver.implicitly_wait(5)
driver.get('http://cdn1.python3.vip/files/selenium/test4.html')

# --- alert ---
driver.find_element_by_id('b1').click()

# 打印 弹出框 提示信息
print(driver.switch_to.alert.text) 

# 点击 OK 按钮
driver.switch_to.alert.accept()
```

### Confirm

Confirm弹出框，主要是让用户确认是否要进行某个操作。

比如：当管理员在网站上选择删除某个账号时，就可能会弹出 Confirm弹出框， 要求确认是否确定要删除。

Confirm弹出框 有两个选择供用户选择，分别是 OK 和 Cancel， 分别代表 确定 和 取消 操作。

那么，自动化的时候，代码怎么模拟用户`点击 OK 或者 Cancel` 按钮呢？

selenium提供如下方法进行操作

如果我们想点击 OK 按钮， 还是用刚才的 accept方法，如下

```python
driver.switch_to.alert.accept()
```

如果我们想点击 Cancel 按钮， 可以用 dismiss方法，如下

```python
driver.switch_to.alert.dismiss()
```

```python
from selenium import webdriver
driver = webdriver.Chrome()
driver.implicitly_wait(5)
driver.get('http://cdn1.python3.vip/files/selenium/test4.html')

# --- confirm ---
driver.find_element_by_id('b2').click()

# 打印 弹出框 提示信息
print(driver.switch_to.alert.text)

# 点击 OK 按钮 
driver.switch_to.alert.accept()

driver.find_element_by_id('b2').click()

# 点击 取消 按钮
driver.switch_to.alert.dismiss()
```

### Prompt

出现 Prompt 弹出框 是需要用户输入一些信息，提交上去。

比如：当管理员在网站上选择给某个账号延期时，就可能会弹出 Prompt 弹出框， 要求输入延期多长时间。

可以调用如下方法

```python
driver.switch_to.alert.send_keys()
```

```python
from selenium import webdriver
driver = webdriver.Chrome()
driver.implicitly_wait(5)
driver.get('http://cdn1.python3.vip/files/selenium/test4.html')

# --- prompt ---
driver.find_element_by_id('b3').click()

# 获取 alert 对象
alert = driver.switch_to.alert

# 打印 弹出框 提示信息
print(alert.text)

# 输入信息，并且点击 OK 按钮 提交
alert.send_keys('web自动化 - selenium')
alert.accept()

# 点击 Cancel 按钮 取消
driver.find_element_by_id('b3').click()
alert = driver.switch_to.alert
alert.dismiss()
```

<aside>
💡 有些弹窗并非浏览器的alert 窗口，而是html元素，这种对话框，只需要通过之前介绍的选择器选中并进行相应的操作就可以了。 {: .notice–info}

</aside>

## 其他技巧

### 窗口大小

有时间我们需要获取窗口的属性和相应的信息，并对窗口进行控制

- 获取窗口大小

```python
driver.get_window_size()

```

- 改变窗口大小

```python
driver.set_window_size(x, y)
```

### 获取当前窗口标题

浏览网页的时候，我们的窗口标题是不断变化的，可以使用WebDriver的title属性来获取当前窗口的标题栏字符串。

```python
driver.title
```

### 获取当前窗口URL地址

```python
driver.current_url

```

例如，访问网易，并获取当前窗口的标题和URL

```python
from selenium import  webdriver

driver = webdriver.Chrome()
driver.implicitly_wait(5)

# 打开网站
driver.get('https://www.163.com')

# 获取网站标题栏文本
print(driver.title) 

# 获取网站地址栏文本
print(driver.current_url) 
```

### 截屏

有的时候，我们需要把浏览器屏幕内容保存为图片文件。

比如，做自动化测试时，一个测试用例检查点发现错误，我们可以截屏为文件，以便测试结束时进行人工核查。

可以使用 WebDriver 的 get_screenshot_as_file方法来截屏并保存为图片。

```python
from selenium import  webdriver

driver = webdriver.Chrome()
driver.implicitly_wait(5)

# 打开网站
driver.get('https://www.baidu.com/')

# 截屏保存为图片文件
driver.get_screenshot_as_file('1.png')
```

### 手机模式

我们可以通过 `desired_capabilities` 参数，指定以手机模式打开chrome浏览器

参考代码，如下

```python
from selenium import webdriver

mobile_emulation = { "deviceName": "Nexus 5" }

chrome_options = webdriver.ChromeOptions()

chrome_options.add_experimental_option("mobileEmulation", mobile_emulation)

driver = webdriver.Chrome( desired_capabilities = chrome_options.to_capabilities())

driver.get('http://www.baidu.com')

input()
driver.quit()

```

### 上传文件

有时候，网站操作需要上传文件。

比如，著名的在线图片压缩网站： https://tinypng.com/

通常，网站页面上传文件的功能，是通过 `type` 属性 为 `file` 的 HTML `input` 元素实现的。

如下所示：

```html
<input type="file" multiple="multiple">

```

使用selenium自动化上传文件，我们只需要定位到该input元素，然后通过 send_keys 方法传入要上传的文件路径即可。

如下所示：

```python
# 先定位到上传文件的 input 元素
ele = wd.find_element_by_css_selector('input[type=file]')

# 再调用 WebElement 对象的 send_keys 方法
ele.send_keys(r'h:\g02.png')

```

如果需要上传多个文件，可以多次调用send_keys，如下

```python
ele = wd.find_element_by_css_selector('input[type=file]')
ele.send_keys(r'h:\g01.png')
ele.send_keys(r'h:\g02.png')
```

## 自动化Edge浏览器

自动化基于Chromium内核的 微软最新Edge浏览器，首先需要查看Edge的版本。

点击菜单 `帮助和反馈` > `关于Microsoft Edge` ，在弹出界面中，查看到版本，比如

```
版本 79.0.309.71 (官方内部版本) (64 位)
```

然后 [点击这里，打开Edge浏览器驱动下载网页](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/#downloads) ，并选择下载对应版本的驱动。

在自动化代码中，指定使用Edge Webdriver类，并且指定 Edge 驱动路径，如下所示

```python
from selenium import webdriver

driver = webdriver.Edge(r'd:\tools\webdrivers\msedgedriver.exe')

driver.get('http://www.51job.com')
```

## 自动化Electron程序

Electron程序都是基于基于Chromium技术开发的，所以基本也可以用Chromedriver驱动自动化。

要自动化，首先需要得到内置 Chromium的版本号。

向开发人员查询打开 Dev Tools 窗口的快捷键（通常是ctrl + Shift + I），打开Dev Tools 窗口后， 在 Console tab中输入 如下语句，查看版本

```
> navigator.appVersion.match(/.*Chrome\/([0-9\.]+)/)[1]
  "79.0.3945.130"

```

然后去 [chromedriver下载网址](https://chromedriver.storage.googleapis.com/index.html) ，下载对应版本的驱动。

在自动化程序中需要指定打开的可执行程序为Electron程序，而不是 Chrome浏览器。

如下所示

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

ops = Options()

# 指定Electron程序路径
ops.binary_location = r"C:\electronAPP.exe"

driver = webdriver.Chrome(r"e:\chromedriver.exe",
                            options = ops)
```

## 黑科技

### 使用代理

selenium 自动化谷歌浏览器可以这样使用代理

```python
from selenium import webdriver
from selenium.webdriver.common.proxy import Proxy, ProxyType

prox = Proxy()
prox.proxy_type = ProxyType.MANUAL
prox.http_proxy = "127.0.0.1:10800"
prox.ssl_proxy = "127.0.0.1:10800"
# prox.socks_proxy = "127.0.0.1:10800"

capabilities = webdriver.DesiredCapabilities.CHROME
prox.add_to_capabilities(capabilities)

driver = webdriver.Chrome(desired_capabilities=capabilities)

driver.get('https://youtube.com')

input()
```

### 使用缺省用户的profile运行浏览器

前面我们selenium打开浏览器，都是创建一个临时的新的用户，在新的用户环境中运行自动化。

如果我们想使用现有缺省用户的 profile运行浏览器自动化，可以这样

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

options = Options()
# 缺省使用的是该目录下面的 Default目录里面保存的用户profile
options.add_argument(r'user-data-dir=c:\Users\baiyh\AppData\Local\Google\Chrome\User Data')
driver = webdriver.Chrome(options=options)
```

### 自动化手工打开的Chrome浏览器

Selenium自动化打开的浏览器，每次都是使用全新的profile，有的网站用 Selenium 自动化，会有奇怪的问题（可能是profile的原因），比如不能登录，打开首页是空白等等。

这时，我们可以

- 先关闭所有的Chrome浏览器
- 然后找到chrome的安装目录，打开命令行窗口，cd进入该目录，
    
    输入如下命令，手动启动Chrome浏览器，指定debug端口。
    
    ```bash
    chrome.exe --remote-debugging-port=9222
    ```
    
    因为没有 –user-data-dir 参数，使用的是缺省用户profile。就是我们手动直接启动Chrome使用的profile。
    
    这一步，也可以不这么麻烦，[参考这篇文章](https://stackoverflow.com/a/56457835/13163813)，修改chrome桌面快捷图标启动参数，修改后双击打开Chrome
    
- 然后 手动操作浏览器网页，比如登录，进入到可以自动化的状态，
- 然后，自动化程序中这样写
    
    ```python
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    
    options = Options()
    # 指定Chrome的debug地址 和前面命令行中启动参数一致
    # 这样，就会直接自动化刚才启动的浏览器
    options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
    
    wd = webdriver.Chrome(options=options)
    wd.implicitly_wait(10)
    
    # 下面接着写自动化的代码
    ```
    
    ### 无头模式